; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+c o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Starting Jack-in Terminal: clojure -Sdeps '{:deps {nrepl/nrepl {:mvn/version,"0.8.3"},cider/cider-nrepl {:mvn/version,"0.26.0"}}}'  -m nrepl.cmdline --middleware "[cider.nrepl/cider-middleware]"
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS: 
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉> 
; Jack-in done.
clj꞉user꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (src/exercism/clojure_representer.clj:12:3).
; No such namespace: z
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/two-fer
clj꞉exercism.clojure-representer꞉> 
[{:tag :list,
  :format-string "(%s)",
  :wrap-length 2,
  :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
  :children
  ({:value ns, :string-value "ns", :map-qualifier nil}
   {:whitespace " "}
   {:value two-fer, :string-value "two-fer", :map-qualifier nil})}
 {:l [],
  :pnodes
  [{:children
    ({:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value ns, :string-value "ns", :map-qualifier nil}
       {:whitespace " "}
       {:value two-fer, :string-value "two-fer", :map-qualifier nil})}
     {:newlines "\n\n"}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value defn, :string-value "defn", :map-qualifier nil}
       {:whitespace " "}
       {:value two-fer, :string-value "two-fer", :map-qualifier nil}
       {:newlines "\n"}
       {:whitespace "  "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
         {:whitespace " "}
         {:tag :list,
          :format-string "(%s)",
          :wrap-length 2,
          :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
          :children
          ({:value str, :string-value "str", :map-qualifier nil}
           {:whitespace " "}
           {:lines ["One for you, one for me."]})})}
       {:newlines "\n"}
       {:whitespace "  "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:tag :vector,
          :format-string "[%s]",
          :wrap-length 2,
          :seq-fn #function[clojure.core/vec],
          :children ({:value name, :string-value "name", :map-qualifier nil})}
         {:whitespace " "}
         {:tag :list,
          :format-string "(%s)",
          :wrap-length 2,
          :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
          :children
          ({:value str, :string-value "str", :map-qualifier nil}
           {:whitespace " "}
           {:lines ["One for "]}
           {:whitespace " "}
           {:value name, :string-value "name", :map-qualifier nil}
           {:whitespace " "}
           {:lines [", one for me."]})})}
       {:newlines "\n"}
       {:whitespace "  "})}
     {:newlines "\n"})}],
  :ppath nil,
  :r
  ({:newlines "\n\n"}
   {:tag :list,
    :format-string "(%s)",
    :wrap-length 2,
    :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
    :children
    ({:value defn, :string-value "defn", :map-qualifier nil}
     {:whitespace " "}
     {:value two-fer, :string-value "two-fer", :map-qualifier nil}
     {:newlines "\n"}
     {:whitespace "  "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
       {:whitespace " "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:value str, :string-value "str", :map-qualifier nil}
         {:whitespace " "}
         {:lines ["One for you, one for me."]})})}
     {:newlines "\n"}
     {:whitespace "  "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:tag :vector,
        :format-string "[%s]",
        :wrap-length 2,
        :seq-fn #function[clojure.core/vec],
        :children ({:value name, :string-value "name", :map-qualifier nil})}
       {:whitespace " "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:value str, :string-value "str", :map-qualifier nil}
         {:whitespace " "}
         {:lines ["One for "]}
         {:whitespace " "}
         {:value name, :string-value "name", :map-qualifier nil}
         {:whitespace " "}
         {:lines [", one for me."]})})}
     {:newlines "\n"}
     {:whitespace "  "})}
   {:newlines "\n"})}]
clj꞉exercism.clojure-representer꞉> 
[{:value defn, :string-value "defn", :map-qualifier nil}
 {:l [],
  :pnodes
  [{:children
    ({:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value ns, :string-value "ns", :map-qualifier nil}
       {:whitespace " "}
       {:value two-fer, :string-value "two-fer", :map-qualifier nil})}
     {:newlines "\n\n"}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value defn, :string-value "defn", :map-qualifier nil}
       {:whitespace " "}
       {:value two-fer, :string-value "two-fer", :map-qualifier nil}
       {:newlines "\n"}
       {:whitespace "  "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
         {:whitespace " "}
         {:tag :list,
          :format-string "(%s)",
          :wrap-length 2,
          :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
          :children
          ({:value str, :string-value "str", :map-qualifier nil}
           {:whitespace " "}
           {:lines ["One for you, one for me."]})})}
       {:newlines "\n"}
       {:whitespace "  "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:tag :vector,
          :format-string "[%s]",
          :wrap-length 2,
          :seq-fn #function[clojure.core/vec],
          :children ({:value name, :string-value "name", :map-qualifier nil})}
         {:whitespace " "}
         {:tag :list,
          :format-string "(%s)",
          :wrap-length 2,
          :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
          :children
          ({:value str, :string-value "str", :map-qualifier nil}
           {:whitespace " "}
           {:lines ["One for "]}
           {:whitespace " "}
           {:value name, :string-value "name", :map-qualifier nil}
           {:whitespace " "}
           {:lines [", one for me."]})})}
       {:newlines "\n"}
       {:whitespace "  "})}
     {:newlines "\n"})}
   {:tag :list,
    :format-string "(%s)",
    :wrap-length 2,
    :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
    :children
    ({:value defn, :string-value "defn", :map-qualifier nil}
     {:whitespace " "}
     {:value two-fer, :string-value "two-fer", :map-qualifier nil}
     {:newlines "\n"}
     {:whitespace "  "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
       {:whitespace " "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:value str, :string-value "str", :map-qualifier nil}
         {:whitespace " "}
         {:lines ["One for you, one for me."]})})}
     {:newlines "\n"}
     {:whitespace "  "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:tag :vector,
        :format-string "[%s]",
        :wrap-length 2,
        :seq-fn #function[clojure.core/vec],
        :children ({:value name, :string-value "name", :map-qualifier nil})}
       {:whitespace " "}
       {:tag :list,
        :format-string "(%s)",
        :wrap-length 2,
        :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
        :children
        ({:value str, :string-value "str", :map-qualifier nil}
         {:whitespace " "}
         {:lines ["One for "]}
         {:whitespace " "}
         {:value name, :string-value "name", :map-qualifier nil}
         {:whitespace " "}
         {:lines [", one for me."]})})}
     {:newlines "\n"}
     {:whitespace "  "})}],
  :ppath
  {:l
   [{:tag :list,
     :format-string "(%s)",
     :wrap-length 2,
     :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
     :children
     ({:value ns, :string-value "ns", :map-qualifier nil}
      {:whitespace " "}
      {:value two-fer, :string-value "two-fer", :map-qualifier nil})}
    {:newlines "\n\n"}],
   :pnodes
   [{:children
     ({:tag :list,
       :format-string "(%s)",
       :wrap-length 2,
       :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
       :children
       ({:value ns, :string-value "ns", :map-qualifier nil}
        {:whitespace " "}
        {:value two-fer, :string-value "two-fer", :map-qualifier nil})}
      {:newlines "\n\n"}
      {:tag :list,
       :format-string "(%s)",
       :wrap-length 2,
       :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
       :children
       ({:value defn, :string-value "defn", :map-qualifier nil}
        {:whitespace " "}
        {:value two-fer, :string-value "two-fer", :map-qualifier nil}
        {:newlines "\n"}
        {:whitespace "  "}
        {:tag :list,
         :format-string "(%s)",
         :wrap-length 2,
         :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
         :children
         ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
          {:whitespace " "}
          {:tag :list,
           :format-string "(%s)",
           :wrap-length 2,
           :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
           :children
           ({:value str, :string-value "str", :map-qualifier nil}
            {:whitespace " "}
            {:lines ["One for you, one for me."]})})}
        {:newlines "\n"}
        {:whitespace "  "}
        {:tag :list,
         :format-string "(%s)",
         :wrap-length 2,
         :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
         :children
         ({:tag :vector,
           :format-string "[%s]",
           :wrap-length 2,
           :seq-fn #function[clojure.core/vec],
           :children ({:value name, :string-value "name", :map-qualifier nil})}
          {:whitespace " "}
          {:tag :list,
           :format-string "(%s)",
           :wrap-length 2,
           :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
           :children
           ({:value str, :string-value "str", :map-qualifier nil}
            {:whitespace " "}
            {:lines ["One for "]}
            {:whitespace " "}
            {:value name, :string-value "name", :map-qualifier nil}
            {:whitespace " "}
            {:lines [", one for me."]})})}
        {:newlines "\n"}
        {:whitespace "  "})}
      {:newlines "\n"})}],
   :ppath nil,
   :r ({:newlines "\n"})},
  :r
  ({:whitespace " "}
   {:value two-fer, :string-value "two-fer", :map-qualifier nil}
   {:newlines "\n"}
   {:whitespace "  "}
   {:tag :list,
    :format-string "(%s)",
    :wrap-length 2,
    :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
    :children
    ({:tag :vector, :format-string "[%s]", :wrap-length 2, :seq-fn #function[clojure.core/vec], :children ()}
     {:whitespace " "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value str, :string-value "str", :map-qualifier nil}
       {:whitespace " "}
       {:lines ["One for you, one for me."]})})}
   {:newlines "\n"}
   {:whitespace "  "}
   {:tag :list,
    :format-string "(%s)",
    :wrap-length 2,
    :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
    :children
    ({:tag :vector,
      :format-string "[%s]",
      :wrap-length 2,
      :seq-fn #function[clojure.core/vec],
      :children ({:value name, :string-value "name", :map-qualifier nil})}
     {:whitespace " "}
     {:tag :list,
      :format-string "(%s)",
      :wrap-length 2,
      :seq-fn #function[rewrite-clj.node.seq/list-node/fn--7693],
      :children
      ({:value str, :string-value "str", :map-qualifier nil}
       {:whitespace " "}
       {:lines ["One for "]}
       {:whitespace " "}
       {:value name, :string-value "name", :map-qualifier nil}
       {:whitespace " "}
       {:lines [", one for me."]})})}
   {:newlines "\n"}
   {:whitespace "  "})}]
clj꞉exercism.clojure-representer꞉> 
defn
clj꞉exercism.clojure-representer꞉> 
(defn two-fer ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me.")))
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/extract-impl
clj꞉exercism.clojure-representer꞉> 
(defn two-fer ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me.")))
clj꞉exercism.clojure-representer꞉> 
{:children [:meta :init],
 :meta
 {:op :const,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns exercism.clojure-representer,
   :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
  :form
  {:arglists '([] [name]), :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
  :val {:arglists '([] [name]), :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
  :type :map,
  :literal? true,
  :o-tag clojure.lang.PersistentArrayMap,
  :tag clojure.lang.PersistentArrayMap},
 :return-tag java.lang.String,
 :init
 {:children [:meta :expr],
  :meta
  {:op :const,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns exercism.clojure-representer,
    :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
   :form {:rettag nil},
   :val {:rettag nil},
   :type :map,
   :literal? true,
   :o-tag clojure.lang.PersistentArrayMap,
   :tag clojure.lang.PersistentArrayMap},
  :return-tag java.lang.String,
  :op :with-meta,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns exercism.clojure-representer,
   :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
  :o-tag java.lang.Object,
  :expr
  {:children [:methods],
   :return-tag java.lang.String,
   :op :fn,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns exercism.clojure-representer,
    :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
   :o-tag clojure.lang.AFunction,
   :variadic? false,
   :methods
   [{:children [:params :body],
     :loop-id loop_13942,
     :arglist [],
     :params [],
     :fixed-arity 0,
     :op :fn-method,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns exercism.clojure-representer,
      :once false,
      :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
     :o-tag java.lang.Object,
     :variadic? false,
     :form ([] (str "One for you, one for me.")),
     :tag java.lang.Object,
     :body
     {:args
      [{:op :const,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns exercism.clojure-representer,
         :once false,
         :loop-id loop_13942,
         :loop-locals 0,
         :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
        :type :string,
        :literal? true,
        :val "One for you, one for me.",
        :form "One for you, one for me.",
        :o-tag java.lang.String,
        :tag java.lang.String}],
      :children [:fn :args],
      :body? true,
      :fn
      {:meta
       {:added "1.0",
        :ns #namespace[clojure.core],
        :name str,
        :file "clojure/core.clj",
        :static true,
        :column 1,
        :line 544,
        :tag java.lang.String,
        :arglists ([] [x] [x & ys]),
        :doc
        "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
       :return-tag java.lang.String,
       :op :var,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns exercism.clojure-representer,
        :once false,
        :loop-id loop_13942,
        :loop-locals 0,
        :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
       :o-tag java.lang.Object,
       :var #'clojure.core/str,
       :form str,
       :tag clojure.lang.AFunction,
       :arglists ([] [x] [x & ys]),
       :assignable? false},
      :op :invoke,
      :env
      {:context :ctx/return,
       :locals {},
       :ns exercism.clojure-representer,
       :once false,
       :loop-id loop_13942,
       :loop-locals 0,
       :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
      :o-tag java.lang.Object,
      :form (str "One for you, one for me."),
      :tag java.lang.String,
      :raw-forms ((do (str "One for you, one for me.")))}}
    {:children [:params :body],
     :loop-id loop_13943,
     :arglist [name],
     :params
     [{:name name__#0,
       :op :binding,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns exercism.clojure-representer,
        :once false,
        :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
       :o-tag java.lang.Object,
       :variadic? false,
       :arg-id 0,
       :form name,
       :tag java.lang.Object,
       :atom #<Atom@386da42d: {:tag java.lang.Object}>,
       :local :arg}],
     :fixed-arity 1,
     :op :fn-method,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns exercism.clojure-representer,
      :once false,
      :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
     :o-tag java.lang.Object,
     :variadic? false,
     :form ([name] (str "One for " name ", one for me.")),
     :tag java.lang.Object,
     :body
     {:args
      [{:op :const,
        :env
        {:context :ctx/expr,
         :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
         :ns exercism.clojure-representer,
         :once false,
         :loop-id loop_13943,
         :loop-locals 1,
         :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
        :type :string,
        :literal? true,
        :val "One for ",
        :form "One for ",
        :o-tag java.lang.String,
        :tag java.lang.String}
       {:children [],
        :name name__#0,
        :op :local,
        :env
        {:context :ctx/expr,
         :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
         :ns exercism.clojure-representer,
         :once false,
         :loop-id loop_13943,
         :loop-locals 1,
         :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
        :o-tag java.lang.Object,
        :variadic? false,
        :arg-id 0,
        :form name,
        :tag java.lang.Object,
        :atom #<Atom@386da42d: {:tag java.lang.Object}>,
        :local :arg,
        :assignable? false}
       {:op :const,
        :env
        {:context :ctx/expr,
         :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
         :ns exercism.clojure-representer,
         :once false,
         :loop-id loop_13943,
         :loop-locals 1,
         :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
        :type :string,
        :literal? true,
        :val ", one for me.",
        :form ", one for me.",
        :o-tag java.lang.String,
        :tag java.lang.String}],
      :children [:fn :args],
      :body? true,
      :fn
      {:meta
       {:added "1.0",
        :ns #namespace[clojure.core],
        :name str,
        :file "clojure/core.clj",
        :static true,
        :column 1,
        :line 544,
        :tag java.lang.String,
        :arglists ([] [x] [x & ys]),
        :doc
        "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
       :return-tag java.lang.String,
       :op :var,
       :env
       {:context :ctx/expr,
        :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
        :ns exercism.clojure-representer,
        :once false,
        :loop-id loop_13943,
        :loop-locals 1,
        :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
       :o-tag java.lang.Object,
       :var #'clojure.core/str,
       :form str,
       :tag clojure.lang.AFunction,
       :arglists ([] [x] [x & ys]),
       :assignable? false},
      :op :invoke,
      :env
      {:context :ctx/return,
       :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
       :ns exercism.clojure-representer,
       :once false,
       :loop-id loop_13943,
       :loop-locals 1,
       :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
      :o-tag java.lang.Object,
      :form (str "One for " name ", one for me."),
      :tag java.lang.String,
      :raw-forms ((do (str "One for " name ", one for me.")))}}],
   :once false,
   :max-fixed-arity 1,
   :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
   :tag clojure.lang.AFunction,
   :arglists ([] [name])},
  :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
  :tag clojure.lang.AFunction,
  :arglists ([] [name]),
  :raw-forms ((clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))},
 :name two-fer,
 :op :def,
 :env
 {:context :ctx/expr,
  :locals {},
  :ns exercism.clojure-representer,
  :file "/home/porky/exercism/clojure-representer/src/exercism/clojure_representer.clj"},
 :o-tag clojure.lang.Var,
 :var #'exercism.clojure-representer/two-fer,
 :top-level true,
 :form
 (def two-fer (clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me.")))),
 :tag clojure.lang.Var,
 :arglists ([] [name]),
 :raw-forms ((defn two-fer ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))}
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
(def two-fer (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
(def two-fer (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))
clj꞉exercism.clojure-representer꞉> 
(def two-fer (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))
clj꞉exercism.clojure-representer꞉> 
